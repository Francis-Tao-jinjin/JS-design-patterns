## 第三章提出的×××方法

### 3.1×××问题描述
    1.电控云客户端的需求分析
    2.根据需求选取合适的技术
    3.开发过程中某个技术上的难点

**需求：**
功能        | 具体需求
---------- | ------- 
**新建测试**    | 1.上传测试时序表生成新测试提供接线图 <br> 2.显示出电控板与测试盒引脚的对应关系 <br> 3.提示用户启动电控板
**查看测试结果** | 1.显示这次测试基本的信息 <br> 2.展示电控板图实时的输入输出 <br> 3.显示各引脚信号变化的方波图 <br>4.生成用于要求的时序表格
**查看过往测试** | 1.显示测试的当前状态
**对测试的操作** | 1.创建 <br>2.取消<br>&emsp;a.提交测试时序表前取消<br>&emsp;b.提交测试时序表之后，启动电控板之前

用户的使用环境：网络的状况的不是很好，没有办法应付稳定、迅速的数据传输。

从需求来看，我们开发的客户端需要较好的响应、实时性和流畅一致的操作性。简单来说，这个运行在浏览器中的客户端需要表现的更像一般的桌面应用。除此之外，服务端本身有非常复杂的任务需要处理，如果把前端的页面渲染和业务逻辑放在服务端完成的话，无疑会大大增加服务器的负担。基于以上原因，前端的开发模式确定为单页面应用。

**以下是对这个选择的一些分析：**

1. 单页面应用对用户界面有较好的响应，

2. 单页面应用在初次加载完之后，就不需要再从服务器上下载网页了。如果使用传统的服务端渲染页面的方式，那么用户每转换一次页面，就需要重新从服务器上再下载一次。即使是之前已经访问过页面，也是如此。这在网络情况不好的情况下会非常影响体验。但这种方法也有相应的不适合的地方，比如对于规模非常大的网站，用户可以只会访问其中有限的几个页面（相应的可能只需要某几个js模块），如果采用 SPA 一次性将程序全部都下载下来无疑是不合适的。所以在客户端页面数量的设计上，我们也尽量做到精简，基本上做到存在的都是用户必会使用的，在整个操作流程上做到方便快捷。

3. 前后端分离，在各自的开发、维护上都更灵活，现在 JavaScrit 在各个浏览器上已经得到了不错的支持，对于较大型的 js 程序，浏览器也完全可以运行。而且单页面的开发方式和传统的桌面应用开发、移动端应用开发有很多相似指出，在软件的设计上可以借鉴这些已有的经验。而且前后端的分离，可以使服务器更专注于数据处理、收发等更复杂的操作。前端在切换页面的时候也只需要请求新的数据，而页面是可以立即显示的，即使数据还没有到达，也能给用户做出相应的提示。除此之外，如果不同的页面之间存在维护一个相同的状态的需求时，单页面应用可以不使用 localstorage 或重新请求就能更方便的保存、共享该状态。<br>但单页面应用也有不足的地方。虽然如今的浏览器的标准趋于统一，但是各自之间始终存在差异。不过因为这个项目面向的是企业用户，在使用时可以指定使用特定的浏览器访问。

### 确定具体的技术方案
**浏览器平台的选择**

虽然早期 javaScript 一直都只是作为处理表单验证之类的简单的脚本语言，但是其核心一直都提供了非常强大灵活的 OOP 语言能力，从而使得用 js 开发完整的大型程序成为可能。而且在 Google V8 （使用 C++ 编写的高性能 JavaScript 引擎）被推出之后，Js 甚至可以用来开发跨平台的桌面应用。因此，我们的客户端系统在开发、测试和最终用户使用的时候都是制定使用内置了 V8 引擎的 Chrome 浏览器。

**技术框架的选择**

前端系统开发选择的是目前处于稳定迭代中的 Vue.js。接下来会从Web技术的发展入手，详细说明为什么要使用框架，以及为什么选择这个框架。

**AJAX**

首先，需要说明 AJAX（异步的JavaScript与XML技术）的重要意义，这项 2005 年才提出的技术现已成为开发现代web应用的基石。

传统的Web应用允许用户端通过表单和超链接的方式向服务器发起请求，服务器接收并处理传来的表单，然后送回一个新的网页，但这个做法浪费了许多带宽，因为在前后两个页面中的大部分HTML码往往是相同的。由于每次应用的沟通都需要向服务器发送请求，应用的回应时间依赖于服务器的回应时间。这导致了用户界面的回应比本机应用慢得多。

与此不同，AJAX应用可以仅向服务器发送并取回必须的数据，并在客户端采用JavaScript处理来自服务器的回应。因为在服务器和浏览器之间交换的数据大量减少,服务器回应更快了。同时，很多的处理工作可以在发出请求的客户端机器上完成，因此Web服务器的负荷也减少了。

但当时由于浏览器之间的兼容性较差和JavaScript的执行性能的不足，完全使用AJAX开发Web应用（单页面应用的本质）的难度很大。因此开发时仍然将大部分的业务逻辑放在服务器,客户端虽然使用 AJAX 获取数据，但是JavaScript的作用任然局限于动态生成页面上的某个控件、处理DOM事件等不太重要的事情。那之后兴起的JavaScript框架大多都是增强语言特性或简化代码编写的函数库，比如 jQuery 和 Prototype。

**模块化开发**

其次是JavaScript中的模块化开发的实现。由于浏览器加载外部文件的时候顺序加载，因此如果第一份文件的代码使用了第二分文件的数据，但是两者在 html 中加载的顺序颠倒了的话，代码是没有办法正确执行，而且浏览器中JavaScript是不支持模块化的（没有类似C/C++的 ‘include’或Java的‘import’），虽然在 ES6 中已经将 module 列入规范，但是目前依然没有办法直接在浏览器中使用。所幸的是，目前有不少的工具库允许在开发的过程中使用模块开发，在build时根据文件之间的引用关系，将多个文件的源码打包成一个文件。

**软件架构模型**

随着浏览器性能的增长，之前难以完成的“重前端”慢慢的在技术上得到了实现。传统的 MVC，MVP，MVVM 软件架构分层的思想在 JavaScript 中都能运用（传统在 JavaWeb 中同样会大量运用这些架构，但那是在服务器上的实现，现在则是在客户端上的实现）。接下来会用一些篇幅介绍这三种架构，因为我们使用的 Vue.js 框架就是在这些架构基础之上实现的。

1. MVC 
[IBM Research Report
Web-Application Development Using the
Model/View/Controller Design Pattern ](http://domino.watson.ibm.com/library/cyberdig.nsf/papers/696CFBA5D4B1E68985256A1E00626E27/$File/rc22002.pdf)<br>
使用组件式开发，常常会将视图、数据、业务逻辑放在同一个模块内，如果组件数目较多、层级关系又较复杂，会使开发和维护的难度大大增加。<br>
MVC（模型 Model - 视图 View - 控制器 Controller）用一种将业务逻辑、数据、视图分离的方式组织架构代码。<br><br>
**Model** 封装了与应用程序的业务逻辑相关的数据以及对数据的处理方法，它可以简单的只包含一个字符串，也可以包含许多复杂的对象。[A Cookbook for Using View-Controller User the ModelInterface Paradigm in Smalltalk-80 ](https://www.lri.fr/~mbl/ENS/FONDIHM/2013/papers/Krasner-JOOP88.pdf)Model 不依赖 View 和Controller ，也就是说， Model 不关心它会被如何显示或是如何被操作。但是 Model 中数据的变化一般会通过一种刷新机制被公布。为了实现这种机制，那些用于监视此 Model 的 View 必须事先在此 Model 上注册，从而，View 可以了解在数据 Model 上发生的改变（观察者模式 Observer）。<br><br>
**View** 根据数据渲染视图，在不同的软件中，View 的具体实现会有很大的区别，但在单页面应用中，可以简单的概括成通过模板字符串渲染新的 HTML 页面。在 MVC 的设计中，View 中保存着用于创建 HTML 的模板字符串和所需要的数据的引用（这也是 MVC 在某些情况下变得不太适用的原因）。<br><br>
**Controller** 主要处理交互和业务逻辑。它可以使用 Model 提供的接口来更新 Model 比如通过监听用户输入获知数据更新 Model。所有对 DOM 事件的监听、处理，异步请求、都由 Controller 负责。<br><br>
不过 MVC 更多的是一种思想而不是固定不变的架构，所以在实际的操作中，经常会根据软件具体的需求来对上面介绍的模式做出改动。比如 MVP 其实是对 MVC 进行改动发展出的一种架构，其解决的是 MVC 中 Modle 和 View 之间耦合度较高的问题。

2. MVP<br>
MVC 模式开发中，View 会直接引用 Model 中的数据，而之间任何变动，Controller 都无法获知。而且，如果 Model 在开发的过程中发生变动，即使渲染的结果没有区别，View 也要做出相应的改动。<br><br>
解决的办法就是取消 View 对 Model 的直接引用，把数据提取的工作交给 Presenter（从 Controller 演变而来）。因此在这个结构中，Presenter 位于中央，负责管理数据、视图创建、交互逻辑和业务逻辑。比 MVC 中的 Controller 功能更多更复杂。<br><br>
如此一来 View 的职责变得更加专一，从 Presenter 接收模板字符串和数据，输出渲染得到的 HTML 页面。这时，View 和 Model 以及业务逻辑完全解耦，甚至完全不同的两个项目可以使用同样的 View。所以，许多专门负责视图渲染的的模板引擎被开发了出来，使开发人员只需要编写模板，而不需要关心模板到底是怎么被转换成 HTML 的。<br><br>
此时，开发人员只需要编写 Model 和 Presenter。虽然 Presenter 变得更加复杂，但是可以在再将其中的和模板字符串相关的部分单独分离出来。目前的诸多前端框架（比如 AngularJs、Vue.js）中的 Templates 其实就是单独分离出来的模板字符串。这样做的好处是，虽然如今开发人员不再直接单独编写 HTML 代码，但是任然可以单独编写 Templates，而不用担心因为其和业务逻辑等代码嵌在一起而难以同步开发。尤其是在 UI 需要频繁变动的情况下，单独编写 Templates 可以将其对业务逻辑的影响降到最低。<br><br>










