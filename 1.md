## 第三章提出的×××方法

### 3.1×××问题描述
    1.电控云客户端的需求分析
    2.根据需求选取合适的技术
    3.开发过程中某个技术上的难点

**需求：**
功能        | 具体需求
---------- | ------- 
**新建测试**    | 1.上传测试时序表生成新测试提供接线图 <br> 2.显示出电控板与测试盒引脚的对应关系 <br> 3.提示用户启动电控板
**查看测试结果** | 1.显示这次测试基本的信息 <br> 2.展示电控板图实时的输入输出 <br> 3.显示各引脚信号变化的方波图 <br>4.生成用于要求的时序表格
**查看过往测试** | 1.显示测试的当前状态
**对测试的操作** | 1.创建 <br>2.取消<br>&emsp;a.提交测试时序表前取消<br>&emsp;b.提交测试时序表之后，启动电控板之前

用户的使用环境：网络的状况的不是很好，没有办法应付稳定、迅速的数据传输。

从需求来看，我们开发的客户端需要较好的响应、实时性和流畅一致的操作性。简单来说，这个运行在浏览器中的客户端需要表现的更像一般的桌面应用。除此之外，服务端本身有非常复杂的任务需要处理，如果把前端的页面渲染和业务逻辑放在服务端完成的话，无疑会大大增加服务器的负担。基于以上原因，前端的开发模式确定为单页面应用。

**以下是对这个选择的一些分析：**

1. 单页面应用对用户界面有较好的响应，

2. 单页面应用在初次加载完之后，就不需要再从服务器上下载网页了。如果使用传统的服务端渲染页面的方式，那么用户每转换一次页面，就需要重新从服务器上再下载一次。即使是之前已经访问过页面，也是如此。这在网络情况不好的情况下会非常影响体验。但这种方法也有相应的不适合的地方，比如对于规模非常大的网站，用户可以只会访问其中有限的几个页面（相应的可能只需要某几个js模块），如果采用 SPA 一次性将程序全部都下载下来无疑是不合适的。所以在客户端页面数量的设计上，我们也尽量做到精简，基本上做到存在的都是用户必会使用的，在整个操作流程上做到方便快捷。

3. 前后端分离，在各自的开发、维护上都更灵活，现在 JavaScrit 在各个浏览器上已经得到了不错的支持，对于较大型的 js 程序，浏览器也完全可以运行。而且单页面的开发方式和传统的桌面应用开发、移动端应用开发有很多相似指出，在软件的设计上可以借鉴这些已有的经验。而且前后端的分离，可以使服务器更专注于数据处理、收发等更复杂的操作。前端在切换页面的时候也只需要请求新的数据，而页面是可以立即显示的，即使数据还没有到达，也能给用户做出相应的提示。除此之外，如果不同的页面之间存在维护一个相同的状态的需求时，单页面应用可以不使用 localstorage 或重新请求就能更方便的保存、共享该状态。<br>但单页面应用也有不足的地方。虽然如今的浏览器的标准趋于统一，但是各自之间始终存在差异。不过因为这个项目面向的是企业用户，在使用时可以指定使用特定的浏览器访问。

### 确定具体的技术方案
**浏览器平台的选择**

虽然早期 javaScript 一直都只是作为处理表单验证之类的简单的脚本语言，但是其核心一直都提供了非常强大灵活的 OOP 语言能力，从而使得用 js 开发完整的大型程序成为可能。而且在 Google V8 （使用 C++ 编写的高性能 JavaScript 引擎）被推出之后，Js 甚至可以用来开发跨平台的桌面应用。因此，我们的客户端系统在开发、测试和最终用户使用的时候都是制定使用内置了 V8 引擎的 Chrome 浏览器。

**技术框架的选择**

前端系统开发选择的是目前处于稳定迭代中的 Vue.js。接下来会从Web技术的发展入手，详细说明为什么要使用框架，以及为什么选择这个框架。

**AJAX**

首先，需要说明 AJAX（异步的JavaScript与XML技术）的重要意义，这项 2005 年才提出的技术现已成为开发现代web应用的基石。

传统的Web应用允许用户端通过表单和超链接的方式向服务器发起请求，服务器接收并处理传来的表单，然后送回一个新的网页，但这个做法浪费了许多带宽，因为在前后两个页面中的大部分HTML码往往是相同的。由于每次应用的沟通都需要向服务器发送请求，应用的回应时间依赖于服务器的回应时间。这导致了用户界面的回应比本机应用慢得多。

与此不同，AJAX应用可以仅向服务器发送并取回必须的数据，并在客户端采用JavaScript处理来自服务器的回应。因为在服务器和浏览器之间交换的数据大量减少,服务器回应更快了。同时，很多的处理工作可以在发出请求的客户端机器上完成，因此Web服务器的负荷也减少了。

但当时由于浏览器之间的兼容性较差和JavaScript的执行性能的不足，完全使用AJAX开发Web应用（单页面应用的本质）的难度很大。因此开发时仍然将大部分的业务逻辑放在服务器,客户端虽然使用 AJAX 获取数据，但是JavaScript的作用任然局限于动态生成页面上的某个控件、处理DOM事件等不太重要的事情。那之后兴起的JavaScript框架大多都是增强语言特性或简化代码编写的函数库，比如 jQuery 和 Prototype。

**模块化开发**

其次是JavaScript中的模块化开发的实现。由于浏览器加载外部文件的时候顺序加载，因此如果第一份文件的代码使用了第二分文件的数据，但是两者在 html 中加载的顺序颠倒了的话，代码是没有办法正确执行，而且浏览器中JavaScript是不支持模块化的（没有类似C/C++的 ‘include’或Java的‘import’），虽然在 ES6 中已经将 module 列入规范，但是目前依然没有办法直接在浏览器中使用。所幸的是，目前有不少的工具库允许在开发的过程中使用模块开发，在build时根据文件之间的引用关系，将多个文件的源码打包成一个文件。

**软件架构模型**

随着浏览器性能的增长，之前难以完成的“重前端”慢慢的在技术上得到了实现。传统的 MVC，MVP，MVVM 软件架构分层的思想在 JavaScript 中都能运用（传统在 JavaWeb 中同样会大量运用这些架构，但那是在服务器上的实现，现在则是在客户端上的实现）。接下来会用一些篇幅介绍这三种架构，因为我们使用的 Vue.js 框架就是在这些架构基础之上实现的。

1. MVC 
[IBM Research Report
Web-Application Development Using the
Model/View/Controller Design Pattern ](http://domino.watson.ibm.com/library/cyberdig.nsf/papers/696CFBA5D4B1E68985256A1E00626E27/$File/rc22002.pdf)<br>
使用组件式开发，常常会将视图、数据、业务逻辑放在同一个模块内，如果组件数目较多、层级关系又较复杂，会使开发和维护的难度大大增加。<br>
MVC（模型 Model - 视图 View - 控制器 Controller）用一种将业务逻辑、数据、视图分离的方式组织架构代码。<br><br>
**Model** 封装了与应用程序的业务逻辑相关的数据以及对数据的处理方法，它可以简单的只包含一个字符串，也可以包含许多复杂的对象。[A Cookbook for Using View-Controller User the ModelInterface Paradigm in Smalltalk-80 ](https://www.lri.fr/~mbl/ENS/FONDIHM/2013/papers/Krasner-JOOP88.pdf)Model 不依赖 View 和Controller ，也就是说， Model 不关心它会被如何显示或是如何被操作。但是 Model 中数据的变化一般会通过一种刷新机制被公布。为了实现这种机制，那些用于监视此 Model 的 View 必须事先在此 Model 上注册，从而，View 可以了解在数据 Model 上发生的改变（观察者模式 Observer）。<br><br>
**View** 根据数据渲染视图，在不同的软件中，View 的具体实现会有很大的区别，但在单页面应用中，可以简单的概括成通过模板字符串渲染新的 HTML 页面。在 MVC 的设计中，View 中保存着用于创建 HTML 的模板字符串和所需要的数据的引用（这也是 MVC 在某些情况下变得不太适用的原因）。<br><br>
**Controller** 主要处理交互和业务逻辑。它可以使用 Model 提供的接口来更新 Model 比如通过监听用户输入获知数据更新 Model。所有对 DOM 事件的监听、处理，异步请求、都由 Controller 负责。<br><br>
不过 MVC 更多的是一种思想而不是固定不变的架构，所以在实际的操作中，经常会根据软件具体的需求来对上面介绍的模式做出改动。比如 MVP 其实是对 MVC 进行改动发展出的一种架构，其解决的是 MVC 中 Modle 和 View 之间耦合度较高的问题。
<img style="display: block; height: 300px; margin: auto;" src="https://upload.wikimedia.org/wikipedia/commons/a/a0/MVC-Process.svg">
2. MVP<br>
MVC 模式开发中，View 会直接引用 Model 中的数据，而之间任何变动，Controller 都无法获知。而且，如果 Model 在开发的过程中发生变动，即使渲染的结果没有区别，View 也要做出相应的改动。<br><br>
解决的办法就是取消 View 对 Model 的直接引用，把数据提取的工作交给 Presenter（从 Controller 演变而来）。因此在这个结构中，Presenter 位于中央，负责管理数据、视图创建、交互逻辑和业务逻辑。比 MVC 中的 Controller 功能更多更复杂。<br><br>
如此一来 View 的职责变得更加专一，从 Presenter 接收模板字符串和数据，输出渲染得到的 HTML 页面。这时，View 和 Model 以及业务逻辑完全解耦，甚至完全不同的两个项目可以使用同样的 View。所以，许多专门负责视图渲染的的模板引擎被开发了出来，使开发人员只需要编写模板，而不需要关心模板到底是怎么被转换成 HTML 的。<br><br>
此时，开发人员只需要编写 Model 和 Presenter。虽然 Presenter 变得更加复杂，但是可以在再将其中的和模板字符串相关的部分单独分离出来。目前的诸多前端框架（比如 AngularJs、Vue.js）中的 Templates 其实就是单独分离出来的模板字符串。这样做的好处是，虽然如今开发人员不再直接单独编写 HTML 代码，但是任然可以单独编写 Templates，而不用担心因为其和业务逻辑等代码嵌在一起而难以同步开发。尤其是在 UI 需要频繁变动的情况下，单独编写 Templates 可以将其对业务逻辑的影响降到最低。<br><br>
<img style="display: block; height: 300px; margin: auto;" src="https://upload.wikimedia.org/wikipedia/commons/d/dc/Model_View_Presenter_GUI_Design_Pattern.png"/>
3. MVVM
不管是 MVC 还是 MVP，视图一直是处于被动的地位，即先有 Model 中具体的数据，再将 View 中使用到的填充进去，数据的流向是 Model -> View，虽然在大部分时候这种模式都没有问题，但是任然有非常不方便的时候，假设有现在这种情况：在当前的页面中有父组件和其中的子组件，子组件专门负责呈现一个特定格式的组件，把他单独独立成一个组件是因为会有多个页面都有这样的表格需求。那么现在需要处理的问题是如何实时有效的将数据从父组件中传入子组件，一个方法是组件提供一个接受新数据的 update 接口，父组件中每次有数据需要渲染的时候，就把新的数据通过 update 传输给子组件。
伪代码：
    ```js
    // child-component
    var child = {
        ...
        model : function(){
            return {
                data : {
                    students: []
                }
            };
        }() 
        ...
    }
    ...
    child.prototype.update = function(newStudents : Array) {
        this.model.data.students.push(...newStudents);
    }
    ```
    ```js
    // parent-component
    ...
    var students = api.getAllStudents();
    if(Object.prototype.toString.call(students) === "[object Array]"){
        child.update(student);
    }
    ...
    ```
    ```html
    <!--父组件 Template 代码-->
    ...
    <parent-component>
        <h2>Student List</h2>
        <child-component></child-component>
    </parent-component>
    ...
    ```
    虽然这种实现方式完全可以，但首先每次更新新数据都要调用子组件的接口，如果父组件有多处都有可能接收数据的话，就要在多个地方调用子组件的接口，如果有某个分之语句忘记调用或者调位置不对，都会造成麻烦。<br>
    其次从父组件的 Template 中可能完全看不出来那个子组件是具体是什么，需要什么数据，只有深入到代码中才能知道为什么要使用它。<br>
    除此之外，通过子组件提供接口的方式不够灵活统一，上面的例子假设子组件只接受一个特定格式的列表数据，如果能有多个可配置的数据需要传入，那么子组件的接口该怎么设计、不同子组件的接口名称、数据格式改如何统一又都成了要花心思设计的事情。<br><br>
    因此，另一种由 View 反过来驱动 Model、Presenter （只是一定程度上的影响）的模式 MVVM 被提出。[The MVVM Pattern](https://msdn.microsoft.com/en-us/library/hh848246.aspx)
    <img style="display: block; height: 300px; margin: auto;" src="https://i-msdn.sec.s-msft.com/dynimg/IC564167.png">

<!--<p style="color:gray">
使用 MVC 或 MVP 在编写 Template 时有非常多类似 Bootstrap 的框架可以帮助开发人员快速的开发出样式精美的组件，但往往也只限于样式，而且自定义组合的 Bootstrap 代码虽然可以封装成一个模块，但是依然是只有样式没有具体的功能。<br>

比如应用中有多个地方会用到同样格式的表格，在使用表格的时候要对数据做一定的格式化，那么如果能把与这个表格有关的 Template 和控制逻辑封装成一个可以接受输入的模块（其实这个想法非常类似函数模块），那只需要在使用的地方调用这个模块，并将数据传入，就能同时获得其渲染出来的表格（视图）以及其对

*在 MVP 中，Template 虽然已经可以和 HTML 代码高度相似且和 Presenter 其余的部分分离，但是其仍然有不方便的地方。假设现在有这样的需求，有一个可变长的列表的数据需要渲染，首先可以确定的是一个一个在 Templats 中的手写 li 元素是错误的，因为列表长度不确定，其次就是使用类似 PHP 的语法，在 Template 中嵌入循环结构的代码。但是这样把业务逻辑和 Templates 混合在一起的做法其实又违背了 MVC 最初的思想。*</P>-->


4. 前端路由
单页面应用不等于没有多个路由，只是对于在 SPA 中，路由的概念发生了一点点改变。在计算机网络中，路由（Routing）指的都是将数据包从原地址传输到目标地址的过程[wikipedia](https://en.wikipedia.org/wiki/Routing)。在 Web 应用中，路由是指通过 URL 来驱动用户界面（UI）的过程。URL 是每个浏览器都具有的重要特性，并且在用户看来，它具有几个重要的作用：

    - **书签** - 用户可以将 URL 收藏在浏览器中以保存那些他们需要回顾的内容。
    - **分享** - 用户可以通过发送某个页面链接的方式来和他人分享内容。
    - **导航** - URL 被用于驱动浏览器的前进和后退功能

    在传统的web应用架构中，服务器一次性渲染一整个 HTML 页面，这时，URL 是用户访问这个应用的基本入口。每当用户在应用中点击一个 URL 链接，浏览器就会向服务器发送一个 HTTP 请求，而服务器则会通过服务端路由器做出正确的响应（向用户返回请求的页面），于是，用户便可以通过这种方式在应用中到处跳转[来源](https://guide.meteor.com/zh_cn/routing.html)。<br>
    但是在 SPA 中，由于除了第一次加载应用时请求 HTML 页面之外，只要没有启用浏览器刷新，之后用户界面的转变都是在客户端完成，服务端不会设计渲染页面的操作。但是 URL 是每个页面的标识，如果只有一个 URL 的话，那么它就没有办法起到基本的导航的功能。<br><br>
    解决办法就是使用浏览器中 window.loaction（一个对应到 URL 的 BOM 对象）中的 hash 属性，该属性对应到 URL 中的 hash（#号后面的字符），hash 常常用来定向到页面中的某个具体的位置，虽然它属于 URL 的一部分，但是 hash 值的变化会触发 hashchange 事件，但是浏览器不会重新加载，而且导航、书签的功能都不受影响。因此 window.loaction.hash 也就为用于设置客户端路由的最佳的方法。<br><br>
    此时前端路由代表的是应用所处的状态，而特定的状态可以对应特定的页面。当 window.loaction.hash 改变的时候，通知应用渲染新的页面就可以模拟出改变 URL ，驱动页面变化的效果。

5. 





